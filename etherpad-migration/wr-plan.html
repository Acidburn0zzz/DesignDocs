<!doctype html>
<html lang="en">
<head>
<title>wr-plan</title>
<meta name="generator" content="Etherpad">
<meta name="author" content="Etherpad">
<meta name="changedby" content="Etherpad">
<meta charset="utf-8">
<style>
* {
  font-family: arial, sans-serif;
  font-size: 13px;
  line-height: 17px;
}
ul.indent {
  list-style-type: none;
}
ol {
  list-style-type: none;
  padding-left: 0;
}
body > ol {
  counter-reset: first second third fourth fifth sixth seventh eigth ninth tenth eleventh twelth thirteenth fourteenth fifteenth sixteenth;
}
ol > li:before {
  content: counter(first) ". ";
  counter-increment: first;
}
ol > ol > li:before {
  content: counter(first) "." counter(second) ". ";
  counter-increment: second;
}
ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) ". ";
  counter-increment: third;
}
ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) ". ";
  counter-increment: fourth;
}
ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) ". ";
  counter-increment: fifth;
}
ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) ". ";
  counter-increment: sixth;
}
ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) ". ";
  counter-increment: seventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) ". ";
  counter-increment: eigth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) ". ";
  counter-increment: ninth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) ". ";
  counter-increment: tenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) ". ";
  counter-increment: eleventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) ". ";
  counter-increment: twelth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) ". ";
  counter-increment: thirteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) ". ";
  counter-increment: fourteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) ". ";
  counter-increment: fifteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) "." counter(sixthteenth) ". ";
  counter-increment: sixthteenth;
}
ol {
  text-indent: 0px;
}
ol > ol {
  text-indent: 10px;
}
ol > ol > ol {
  text-indent: 20px;
}
ol > ol > ol > ol {
  text-indent: 30px;
}
ol > ol > ol > ol > ol {
  text-indent: 40px;
}
ol > ol > ol > ol > ol > ol {
  text-indent: 50px;
}
ol > ol > ol > ol > ol > ol > ol {
  text-indent: 60px;
}
ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 70px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 80px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 90px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 100px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 110px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 120px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 130px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 140px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 150px;
}

</style>
</head>
<body>
<a href="https&#x3a;&#x2F;&#x2F;public&#x2e;etherpad&#x2d;mozilla&#x2e;org&#x2F;p&#x2F;wr&#x2d;plan">https:&#x2F;&#x2F;public.etherpad-mozilla.org&#x2F;p&#x2F;wr-plan</a><br><br>Proposed plan for using WebRender as a Layers backend:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https&#x3a;&#x2F;&#x2F;public&#x2e;etherpad&#x2d;mozilla&#x2e;org&#x2F;p&#x2F;Gecko&#x2d;WebRenderer">https:&#x2F;&#x2F;public.etherpad-mozilla.org&#x2F;p&#x2F;Gecko-WebRenderer</a><br><ul class="bullet"><li>The goal is to write code that we&#x27;re going to use in the final state, and still have something workable sooner</li><li>We had an earlier idea to have WebRender compositor, which would mean having a WebRender impleGDGFGFDmentation of the Compositor AP</li><ul class="bullet"><li><br></li></ul><li>This plan instead wants to replace more of the layers system by WebRender:</li><ul class="bullet"><li>FrameLayerBuilder stays and creates layers using the LayerManager API</li><li>We create a new LayerManager implementation called WebRenderLayerManager, which replaces ClientLayerManager and would be used by FrameLayerBuilder</li><li>WebRenderLayerManager knows how to serialize the laASDyer tree to a WebRender display list, e.g. turning ASDPaintedLayers into WebRender image display items</li><li>We then send the WebRender display list to the compositor thread and render it using WebRender</li></ul><li>We&#x27;ll need to write these things that we&#x27;ll need for full WebRender in the end anyway:&nbsp;</li><ul class="bullet"><li>WebRender APZ</li><li>texture sharing</li><li>WebRender IPC</li><li>OMTA</li><li>OMTV test abc tesbac</li></ul><li>These things would stay:omtaASDASD</li><ul class="bullet"><li>PaintedLayers, FrameLayerBuilder and Invalidation</li><li>(PaintedLayers are just texture-shared images that get rendered by WebRender image drawing)</li><li>Tiling</li><li>Buffer rotation</li></ul><li>Transition</li><ul class="bullet"><li>We can add more and more supported web render display item types, by creating layer types for them</li><li>For example, for text, we&#x27;d add a TextLayer, which then gets turned into a WebRender text item on the client ly reduce the distance between the APIs, until in the end state we can have one layer type per webrender display item type</li><li>(this means that, since we&#x27;ll sometimes have multiple wr display items per nsDisplayItem, we&#x27;ll need a way to make an nsDisplayItem create multiple layers)</li><li>At that point, we remove the intermediary and directly create WebRender display items from nsDisplayItems</li><li>We&#x27;ll also need invalidation on the WebRender side at that point, and then we remove FrameLayerBuilder</li></ul><li>Advantages:</li><ul class="bullet"><li>Less new code that we&#x27;re not going to use</li><li>Makes the path after this point more parallelizable, because it pulls most of the bottlenecks to the front</li><li>Can get tests passing early and keep them passing</li><li>Will prove all the connections to e.g. the widget system, event handling stuff</li><li>Changes the type of bugs we&#x27;re going to get, for example if something paints wrong, the bug should be known to be where it is in the pipeline (based on what we&#x27;ve changed)</li><li>If some part will take longer, e.g. video, then it wouldn&#x27;t hold up this incremental step, we&#x27;d just make it slower (?)</li></ul><li>Disadvantages:</li><ul class="bullet"><li>Being incremental makes it easier not to finish (we might end up kicking the old infrastructure around forever)</li></ul><li>FAQ:</li><ul class="bullet"><li>Will we be able to ship this intermediate step?</li><ul class="bullet"><li>Most likely not. This is mostly intended so that we can work on more pieces sooner, and keep tests passing during the process.</li></ul><li>Will it speed things up?</li><ul class="bullet"><li>Not sure, but probably not at first. In the beginning it will make many things slower, e.g. we won&#x27;t have APZ until we have APZ for webrender.</li></ul><li>Is there anything smaller that is better and shippable?</li><ul class="bullet"><li>Not sure</li></ul><li>What code will be writing for this intermediate step that we don&#x27;t need in the end?</li><ul class="bullet"><li>WebRenderLayerManager</li><li>additional layer types for any new webrender display types that we add support for (those will only be implemented for WebRenderLayerManager and just be small value containers)</li></ul><li>What directories in gfx&#x2F;layers&#x2F; would stay around?</li><ul class="bullet"><li>apz, basic</li><li>new webrender directory</li><li>maybe layerviewer + protobuf with lots of changes</li></ul><li>Isn&#x27;t layers currently designed with the assumption that there won&#x27;t be &quot;too many&quot; of them? Will there be perf regressions if we start increasing the numbers&#x2F;types of layers?</li><ul class="bullet"><li>This is irrelevant, because the WebRenderLayers are going to be converted to WebRenderDisplayItems almost immediately</li><li>At least if we&#x27;re going with option 2. If we go with option 3, i.e. converting ACM&#x27;d layers on the compositor side, then there will be perf problems with lots of layers.</li></ul><li>How will this coexist with existing layer manager implementations? Will the new layer types have to be supported in existing layer managers? (We should try to avoid littering FrameLayerBuilder with layer-manager-specific conditions)</li><ul class="bullet"><li>The other layer managers can just return null from the CreateXXXLayer() calls, and FrameLayerBuilder would fall back to the path that does not create layers of these types.</li><li>Or the display items could, in GetLayerState(), check the layer manager type and return LAYER_NONE instead of LAYER_(IN)ACTIVE</li></ul><li>Which process will webrender live in, and what&#x27;s the data that gets sent over?</li><ul class="bullet"><li>The current plan is to put webrender into the GPU process, and send over the webrender display list.</li><li>One alternative would be to run webrender in the content process and send over GL commands. But then we&#x27;d still need some way of compositing the result from two different processes.</li></ul><li>What about texture sharing?</li><ul class="bullet"><li>Not sure, but we&#x27;ll probably have to add it at some point, because we&#x27;ll still have things like SVG ( &#x2F; canvas? ) for some time that need to be rasterized on the content side.</li></ul><li>What does the transition plan look like?</li><ul class="bullet"><li>We do something a little bit like this for ImageLayers today</li><ul class="bullet"><li>We have a CanOptimizeToImageLayer() that we call it determines if we can create an image layer</li><ul class="bullet"><li>We can create something like this for WebRender display items</li><li>We&#x27;ll be able to track how much fallback we have happening and reduce it incrementally</li><li><br></li></ul></ul></ul></ul></ul><br>Serialization bottlenecks<br>- texture sharing somewhat blocks video<br>- apz<br>- widget<br><br><a href="https&#x3a;&#x2F;&#x2F;public&#x2e;etherpad&#x2d;mozilla&#x2e;org&#x2F;p&#x2F;wr&#x2d;plan">https:&#x2F;&#x2F;public.etherpad-mozilla.org&#x2F;p&#x2F;wr-plan</a><br>Workitems for initial prototype of WRLayerManger<br>-MaskLayers we need mask image support in WebRender<br>-bring up c bindings for WebRender<br>-Widget stuff<br>-Probably best to start by bringing things up in-process with webrender running synchronously. i.e. make something akin to basic layers<br><br>Questions for webrender people:<br><br><ul class="bullet"><li>Why is a scroll frame different from a regular frame? What happens if we have both a regular paint &#x2F; display list update and a scroll position change? Do the two get coalesced into one composite?</li><ul class="bullet"><li>First let me apologise for some of the naming conventions - they make sense to me coming from a game background but are often ambiguous with web terminology :)</li><li>If I understanding what you&#x27;re asking, a normal frame is when content of the display list has actually changed and we need to rebuild GPU data structures etc.</li><li>In a scroll frame, there&#x27;s no involvement from layout etc, all the data is exactly the same, just the visible viewports are changing.</li><li>There is definitely some coalescing that goes on - for instance, if we very quickly receive 3 new regular frames, we coalesce then. We can tweak this behaviour with scroll frames too if it doesn&#x27;t work quite right now.</li></ul><li>What is the pipeline ID for? How much does it matter?</li><ul class="bullet"><li>In servo, a pipeline ID identifies a top level page or an iframe. For instance, if you have a page that contains 2 iframes, there would be 3 pipeline IDs in the stacking context tree to be drawn (one for the root page, one for each iframe). I&#x27;m not sure how this fits in to gecko terminology.</li></ul><li>What thread is the notifier called on? How should it react to the call?</li><ul class="bullet"><li>It&#x27;s called on the webrender backend thread. In Servo, we use this to call a (thread safe) function that wakes up our main thread (which may be blocked on waiting for UI events). When that thread gets woken up it knows to tell WR to draw the next frame.</li></ul><li>Can you delete an image before you submit a new display list without that image?</li><ul class="bullet"><li>Yes - the idea is that WR handles images (and fonts) by key&#x2F;id for this exact reason. The behaviour should be that the display item referencing a non-existent resource gets dropped and not drawn. If it doesn&#x27;t work that way currently, it&#x27;s a bug.</li></ul><li>Why does a stacking context have multiple display list IDs?</li><ul class="bullet"><li>This is due to the way servo (used to) build display lists in parallel - where there is one &quot;display list&quot; per stacking context (I think). Probably best to get pcwalton to comment on this as I&#x27;m a little fuzzy on the details.</li></ul><li>Is data being retained between frames based on the display list IDs or the stacking context IDs, or can we regenerate these IDs on every frame?</li><ul class="bullet"><li>That data is retained when scrolling (which I believe is similar to APZ) - there is no no data arriving from the layout thread(s) in that case. When you provide a new layout (i.e. via SetRootStackingContext), any existing data is thrown away and so it&#x27;s fine to re-use IDs.</li></ul></ul><br><br>Questions for us:<br><ul class="bullet"><li>The WR display list is processed on a different thread. How do we want that asynchronicity tie in with the rest of Gecko &#x2F; Gecko&#x27;s painting?</li></ul><br><ul class="bullet"><li>(Matt) Is there any advantage to making WebRenderLayerManager work as a replacement for LayerManagerComposite (after layers have been sent to the compositor) rather than ClientLayerManager initially?</li><ul class="bullet"><li>It seems like we could write it this way and then transition it to the client in the future with very little extra work (it&#x27;s just a LM impl, doesn&#x27;t matter if the user is FrameLayerBuilder or LayerTransactionParent).</li><li>This would give us working texture sharing (TextureClient is *huge*, and most of the work we do to serialize all the different surface types would still probably need to exist), async video, APZ etc</li><li>omta</li><li>If this is workable, then we could get some initial data (and maybe even real wins) while we work on WebRender IPC, WebRender APZ etc etc</li></ul><li>I don&#x27;t have any real objection to this plan. I am concerned about the additional serialization overhead though.</li></ul><br>------------------<br><br>Ideas for software webrender backend:<br><br>Invalidation<br>1. Screenspace tile based invalidation (i.e. has the tile changed)<br>2. Scroll layer invalidation. (interleaving things are invalidated everytime)<br>3.&nbsp;<br><br>Invalidation roots<br>- these would be scrollable things, transformed things. These would retain painted versions, but only what&#x27;s visible on the screen<br>- invalidation roots would be largely static<br>- stuff on top not part of the invalidation root is repainted every composite. i.e. if something is inbetween, we propose repainting everything in that area on every composite<br>&nbsp;- e.g. imagine you have some scrollable content that has something inbetween that does not scroll:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - when the scrollable thing scrolls, we repaint the area&nbsp;<br><br>changing content on a page can be handled by doing something like DASDLBI with per tile. We can do this per invalidation root as we needed.<br><br>Don&#x27;t worry about position fixed content? Can we just redraw in time?<br><br><br><br>How to convert a display item type to webrender:<br><br><ol class="number"><li>Find the type that you want to convert in nsDisplayList.h or in nsDispAlayItemTypesList.h.</li><li>Find the nsDisplayItem subclass of that type.</li><li>Add an implementation of nsDisplayItemYourType::GetLayerState and make it return LAYER_ACTIVE for webrender layer managers and LAYER_NONE for the other layer managers.</li><li>Go to Layers.h and add a subclass of Layer for the type that you want to add.</li><li>Go to WebRenderLayerManager.h and add a CreateYourTypeLayer() method (all the other layer managers should return null).</li><li>Add nsDisplayItemYourType::BuildLayer implementation that calls aManager-&gt;CreateYourTypeLayer() and sets the correct values on the layer.</li><li>Before step 6: Figure out what values the layer needs to know about, by reading all the code that is called from nsDisplayItemYourType::Paint.</li><li>In WebRenderYourTypeLayer::RenderLayer, add conversion code to build WebRender items of the right type with the right parameters. Might need new bindings in bindings.rs &#x2F; webrender.h, or even new webrender capabilities.</li></ol><br>Matt has already created layer types for Text and Border, for the simple cases.<br><br>Converting these things is going to be hard:<br><ul class="bullet"><li>Text with SVG glyphs</li><li>text decoration</li><li>text shadow</li><li>text selection</li></ul><br><br>SVG<br>- filters<br><ul class="indent"><li>- build descriptions ahead of time</li></ul>missing things<br>- multiple mask images blended together<br>- clipping to multiple paths<br><br>svg patterns<br>- % patterns make things difficult because we&#x27;d need to do layoutish things<br>- we could flatten out display lists but we might get to many display lists<br><br><br>Idea for supporting text:<br>The problem is that text rendering can do lots of things that webrender won&#x27;t support at first. Ideally, you&#x27;d have a function CheckTextLayerFeasibility that either returns an array of glyphs or false. But the logic for creating such a check would be really complicated; you&#x27;d end up duplicating all of the control flow that is in the regular rendering path.<br>One idea would be to call the regular text rendering code with a recording DrawTarget during display list construction, and then analyze whether there are only FillGlyphs calls in the recording. If yes, extract the array of glyphs; if no, hold on to the recording DrawTarget and execute the drawing commands during actual painting.<br>Another idea would be to create a class that initially just wraps a DrawTarget, and that gets passed into text painting code instead of the actual DrawTarget. (This would require lots of type renaming but shouldn&#x27;t change behavior.) This wrapper class could have an internal (lazily-created) DrawTarget and an array of glyphs. If FillGlyphs is called on the wrapper, the parameters would be added to the glyphs array; if any other drawing method is called, the internal DrawTarget is created, existing recorded FillGlyph calls are executed on it, the FillGlyphs array is discarded, and the current + all future drawing commands is executed directly on this DrawTarget.<br>In the case where WebRender is disabled, the text rendering code would be called at the normal place during painting, and the wrapper class would just forward all calls to the DrawTarget that backs the PaintedLayer that we&#x27;re drawing to.<br><br><strong>Types</strong>: (tag with inactive, started, converted, enabled)&nbsp;<br><ul class="bullet"><li>ALT_FEEDBACK: - <a href="https&#x3a;&#x2F;&#x2F;bugzilla&#x2e;mozilla&#x2e;org&#x2F;show&#x5f;bug&#x2e;cgi&#x3f;id&#x3d;1345388">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1345388</a></li><ul class="bullet"><li>for images that are loading &#x2F; broken, draws a border, or a placeholder image, or a different placeholder image, or the alt text</li><li>detect the state during display list construction, and then create items of the appropriate types.</li></ul><li>BACKGROUND</li><ul class="bullet"><li>can draw a background image or a linear gradient or a radial gradient</li><li>might want to consider splitting those up into separate types</li></ul><li>BACKGROUND_COLOR</li><ul class="bullet"><li>creates a solid color rectangle</li></ul><li>THEMED_BACKGROUND - Keep as painted layer</li><ul class="bullet"><li>for theme drawing; need to create a surface, have the theme draw into it, and give it to webrender as an image.</li></ul><li>BLEND_CONTAINER &#x2F; BLEND_MODE</li><ul class="bullet"><li>container items which we already know how to create layers for; webrender already supports blend modes on stacking contexts.</li></ul><li>BORDER</li><ul class="bullet"><li>can do simple border drawing, multi-colord border drawing, and border-image drawing</li><li>might want to create a new item type for border image</li><li>if multi-colored borders (used for the -moz-border-top&#x2F;right&#x2F;bottom&#x2F;left-colors properties) can be expressed as multiple regular border items, stacked on top of each other, maybe we should split those up during display list construction</li></ul><li>BOX_SHADOW_OUTER &#x2F; BOX_SHADOW_INNER: - outset bug 1347727, inset bug 1349843</li><ul class="bullet"><li>extracting the data should be straightforward. requires new layer type and is already supported by webrender (BoxShadowDisplayItem)</li></ul><li>BULLET: - bug 1339683</li><ul class="bullet"><li>Supports disc, circle, square, disclosure triangle and image.</li><li>disc, circle and square are drawn as glyphs -&gt; text item</li><li>disclosure triangle is a triange path that is filled -&gt; path item</li><li>image -&gt; image item</li></ul><li>BUTTON_BORDER_BACKGROUND: - 1350182</li><ul class="bullet"><li>can hopefully be split somehow into border + inner box shadow</li></ul><li>TYPE_BUTTON_FOREGROUND:</li><ul class="bullet"><li>can be two border items, need to pass a style context (or an nsStyleBorder) to the constructor because outer and inner focus border can be different</li></ul><li>CANVAS_FOCUS:&nbsp;</li><ul class="bullet"><li>border, we should change that to just be a border item</li></ul><li>CARET: bug 1342276</li><ul class="bullet"><li>one or two colored rects</li></ul><li>CHECKED_CHECKBOX:</li><ul class="bullet"><li>either fills a path (checkmark) or a rect (&quot;minus&quot;, when undetermined) -&gt; path item &#x2F; colored rect item, depending on state</li></ul><li>CHECKED_RADIOBUTTON:</li><ul class="bullet"><li>ellipse, should use a webrender path item</li></ul><li>CLEAR_BACKGROUND:</li><ul class="bullet"><li>colored rectangle (transparent) with operator source</li></ul><li>COLUMN_RULE: bug 1344079</li><ul class="bullet"><li>colored rectangle</li></ul><li>COMBOBOX_FOCUS:</li><ul class="bullet"><li>dashed border</li></ul><li>EVENT_RECEIVER, LAYER_EVENT_REGIONS</li><ul class="bullet"><li>depends on what kats decides to do for event regions - todo follow up</li></ul><li>FIELDSET_BORDER_BACKGROUND</li><ul class="bullet"><li>can be split into border and background</li></ul><li>FIXED_POSITION</li><ul class="bullet"><li>just a container, the fixed information could be put on a stacking context</li></ul><li>STICKY_POSITION:</li><ul class="bullet"><li>same thing</li></ul><li>FRAMESET_BORDER:</li><ul class="bullet"><li>border</li></ul><li>FRAMESET_BLANK:</li><ul class="bullet"><li>colored rect</li></ul><li>HEADER_FOOTER:</li><ul class="bullet"><li>draws text. We could create a display item that just accepts text in its constructor and draws it &#x2F; creates a TextLayer.</li></ul><li>IMAGE: x</li><ul class="bullet"><li>image.</li></ul><li>LIST_FOCUS:</li><ul class="bullet"><li>draws a focus border using nsCSSRendering::PaintFocus, can be a border item</li></ul><li>OPTION_EVENT_GRABBER:</li><ul class="bullet"><li>doesn&#x27;t paint anything, don&#x27;t need to do anything</li></ul><li>OUTLINE: - 1348755</li><ul class="bullet"><li>either theme drawing or border, split into two display item types</li></ul><li>OWN_LAYER</li><ul class="bullet"><li>can be flattened away, or can be a stackingcontext with the extra data that is attached, e.g. for scrollbar thumbs</li></ul><li>PLUGIN</li><ul class="bullet"><li>image</li></ul><li>PLUGIN_READBACK</li><ul class="bullet"><li>dead in a webrender world and potentially sooner (only needed needed for windowed plugins, async plugin painting is already used 50%)</li></ul><li>PLUGIN_VIDEO</li><ul class="bullet"><li>android only?</li></ul><li>RANGE_FOCUS_RING</li><ul class="bullet"><li>border</li></ul><li>REMOTE:</li><ul class="bullet"><li>reflayer</li></ul><li>RESOLUTION:</li><ul class="bullet"><li>is a container, already supported as a containerlayer</li></ul><li>SCROLL_INFO_LAYER:</li><ul class="bullet"><li>already builds a layer</li></ul><li>SELECTION_OVERLAY</li><ul class="bullet"><li>one colored rectangle</li></ul><li>SOLID_COLOR: - 1351510&nbsp;</li><ul class="bullet"><li>colored rectangle</li></ul><li>SOLID_COLOR_REGION - 1351511</li><ul class="bullet"><li>list of colored rectangles</li></ul><li>SUBDOCUMENT:</li><ul class="bullet"><li>already a container layer</li></ul><li>MASK</li><ul class="bullet"><li>stacking context with a mask</li></ul><li>FILTER</li><ul class="bullet"><li>stacking context with a filter</li></ul><li>SVG_OUTER_SVG:</li><ul class="bullet"><li>we need to keep this one.</li><li>image: paints the whole &lt;svg&gt;&lt;&#x2F;svg&gt; element as one image</li></ul><li>SVG_TEXT</li><ul class="bullet"><li>calls PaintText on an nsTextFrame, so we need to do the same thing here as for nsDisplayText</li><li>The DrawResult stuff seems unnecessary</li></ul><li>TABLE_CELL_BACKGROUND, TABLE_ROW_BACKGROUND, TABLE_ROW_GROUP_BACKGROUND, TABLE_BORDER_BACKGROUND</li><ul class="bullet"><li>will create regular background items when andrew is done</li></ul><li>TABLE_CELL_SELECTION</li><ul class="bullet"><li>is a border (with &quot;shading&quot; - just make it a simple border without the shading)</li><li>maybe remove the feature? bug 1234067</li></ul><li>TEXT: 1329314</li><ul class="bullet"><li>see above for the text plan</li></ul><li>TEXT_OVERFLOW - 1351508</li><ul class="bullet"><li>draws text (ellipsis or other text) with an optional text shadow, same solution as for the other text display items</li></ul><li>TRANSFORM, PERSPECTIVE, WRAP_LIST:</li><ul class="bullet"><li>containers that already support creating ContainerLayers</li></ul><li>VIDEO</li><ul class="bullet"><li>image</li></ul><li>REFLOW_COUNT</li><ul class="bullet"><li>text</li></ul><li>XUL_EVENT_REDIRECTOR:</li><ul class="bullet"><li>nothing gets painted, don&#x27;t need to worry about this one</li></ul><li>XUL_GROUP_BACKGROUND</li><ul class="bullet"><li>can be refactored to create either one border item or three border items with clips.</li></ul><li>XUL_IMAGE</li><ul class="bullet"><li>image</li></ul><li>XUL_TEXT_BOX</li><ul class="bullet"><li>text + text shadow</li></ul><li>XUL_TREE_BODY</li><ul class="bullet"><li>we&#x27;ll need to keep this one, or do lots of work to break it down to the individual item types, see 5.2 in jeff&#x27;s list below</li></ul><li>XUL_TREE_COL_SPLITTER_TARGET</li><ul class="bullet"><li>just used for hit testing, doesn&#x27;t paint anything.</li></ul><li>XUL_DEBUG:</li><ul class="bullet"><li>Debug only, calls nsBoxFrame::PaintXULDebugOverlay, which calls DrawSpacer, which draws lines and rectangles</li></ul><li>MATHML_BAR</li><ul class="bullet"><li>a colored rectangle</li></ul><li>MATHML_CHAR_BACKGROUND</li><ul class="bullet"><li>kill it (bug 1312130)</li></ul><li>MATHML_CHAR_FOREGROUND</li><ul class="bullet"><li>just text</li></ul><li>MATHML_ERROR</li><ul class="bullet"><li>fillRect + the string &quot;invalid-markup&quot;</li></ul><li>MATHML_MENCLOSE_NOTATION</li><ul class="bullet"><li>paths</li></ul><li>MATHML_SELECTION_RECT</li><ul class="bullet"><li>colored rectangle</li></ul><li>MATHML_SLASH</li><ul class="bullet"><li>path</li></ul><li>MATHML_BOUNDING_METRICS</li><ul class="bullet"><li>just does one StrokeRect. This could be a border, or it could be four colored rects</li></ul><li>MATHML_CHAR_DEBUG</li><ul class="bullet"><li>two borders</li></ul><li>DEBUG_BORDER, DEBUG_IMAGE_MAP, DEBUG_PLACEHOLDER, EVENT_TARGET_BORDER</li><ul class="bullet"><li>debug only, can just fall back to PaintedLayers forever (maybe not forever)</li></ul></ul><br>We should figure out all the places where we draw borders and write down what pieces we need. Create a new nsDisplayBorderSomething class that takes an nsStyleBorder in the constructor? Or a rect, border color + border width?<br><br>We should minimize the list of display item types by merging some of our display item classes, e.g. all solid color rects (SOLID_COLOR, FRAMESET_BLANK, CARET), all borders (borders, outlines, focus outlines), ...<br>These classes need to return different perframekeys for the different parts of an nsIFrame that they&#x27;re used for. For example, if we have a frame with a border and an outline, and we use the same display item type for both, then DLBI needs to be able to differentiate between the two items.<br><br>Display items<br><ol class="number"><li>Images</li><ol class="number"><li>How do they get to the webrender process? Currently it looks like ipc-channel copies the data</li><li>How do we avoid not using more memory than gecko currently does for images?</li><ol class="number"><li>i.e. We&#x27;d rather not have two copies of every image on a page in memory</li></ol><li>Create some image memory stress tests</li><li>make sure we handle keeping things around for the unaccelerated side</li><li>Current plan is to add and remove images based on Lock&#x2F;Unlock()</li><ol class="number"><li>nsDocument::AddImage</li><li>nsDocument::RemoveImage</li></ol><li>high quality downscaling</li></ol><li>SVG</li><ol class="number"><li><a href="https&#x3a;&#x2F;&#x2F;public&#x2e;etherpad&#x2d;mozilla&#x2e;org&#x2F;p&#x2F;svg&#x2d;perf">https:&#x2F;&#x2F;public.etherpad-mozilla.org&#x2F;p&#x2F;svg-perf</a></li><li>Two possible approaches</li><ol class="number"><li>Native support for SVG display items</li><ol class="number"><li>Probably good to bring up servo&#x27;s SVG renderer as soon as possible</li><li>What would the performance of this approach be? (Probably not worse than cairo software rendering)</li><ol class="number"><li>For svg geometry frame it may be worth special casing the following</li></ol></ol><li>Treat it like canvas</li></ol></ol><li>Text</li><ol class="number"><li>Font memory management may be a concern</li></ol><li>Fonts</li><li>XUL</li><ol class="number"><li>Most of XUL should be pretty easy</li><li>XUL Tree (this could be lowered to other display items ahead of time)</li><ol class="number"><li>Seperator</li><li>Row</li><li>Column</li><li>DropFeedback</li><li>ProgressMeter</li><li>CheckBox</li><li>Text</li><li>Image</li><li>Cell</li><li>Twisty</li></ol></ol><li>Canvas</li><ol class="number"><li>HW accelerated canvas</li><ol class="number"><li>texture sharing of some sort (mchang)</li></ol></ol><li>Video</li><ol class="number"><li>DXVA</li><li>IOSurfaces</li><li>Android stuff</li></ol></ol>Misc<br><ol class="number"><li>windows ipc channel port</li></ol><br>Servo missing functionality<br><ul class="bullet"><li>border-image (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13003">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13003</a> )</li></ul><br>ImageBridge<br><ul class="bullet"><li><br></li></ul><br>WebRender missing capabilities<br><ol class="number"><li>Subpixel text</li><li>elaborate border rendering</li><li>svg filters</li><li>directwrite</li><li>background-repeat: space (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;363">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;363</a> )</li><li>clipping to text (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;360">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;360</a> )</li><li>subimage repeat ( <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13003">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13003</a> )</li><li>hit testing (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;411&#x29;">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;411)</a></li><li>mask images (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;405&#x29;">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;405)</a></li><li>mutliple windows (<a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13338&#x29;">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;servo&#x2F;issues&#x2F;13338)</a></li><li>timed async images&#x2F;pick video frame on composition</li><li>radial gradients</li><li>alpha masks</li><li>anti-aliased edges on transforms</li><li>blend modes</li><li>plane splitting</li><li>Color Management (not required for shipping_</li></ol><br>Concerns<br><ol class="number"><li>fatness of WR display items for something like SVG (they&#x27;ll be much fatter than nsDisplayItems which mostly just contain pointers to the frames)</li><li>memory usage overall</li></ol><br>Probably worth doing a bit of a WR in gecko prototype:<br><ul class="indent"><li>and then throwing the thing away and doing it more properly</li><li><br></li></ul>Overall, nsDisplayItems are very thin and heavily tied to their frames. by the way, I never said that it wan&#x27;t true.&nbsp; By the time we actually get to drawing there&#x27;s quite a bit of stuff that happens inbetween at least for image drawing. It may<br>make sense to make the cut over to webrender at a lower level in the drawing process.<br><br>Code that&#x27;s being replaced:<br>&nbsp;&nbsp;&nbsp; gfx&#x2F;layers&#x2F;*<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>bindings:<br>&nbsp;&nbsp;&nbsp; <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;374">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;374</a><br><br><br>Gecko fixes needed:<br>&nbsp;&nbsp;&nbsp; - display item per background layer (all that&#x27;s missing now are tables)<br><ol><ol class="number"><li>Remove legacy background layer drawing</li><ol class="number"><li>MathML</li><li>XUL Tree</li><li>Masks (how to do this a question mark)</li><li>Border collapse tables</li></ol></ol></ol><br>Risks:<br><ul class="bullet"><li>we lose smooth scrolling on pages that are complicated to draw every frame</li><ul class="bullet"><li>(vlad) assuming nothing actually changed, can we cache on the WR side as a performance optimization?</li><ul class="bullet"><li>requires either full FrameLayerBuilder-style layerization, or something simpler as discussed in the software rendering section (retain as one layer and always redraw overlapping parts of the screen)</li></ul></ul></ul><br>APZ:<br><ul class="bullet"><li>keep APZCs, replace ACM (AsyncCompositionManager) with a rust + webrender equivalent</li><li>Compositor&#x2F;APZ hit testing</li><ul class="bullet"><li>Four options, we&#x27;re going to choose (1) to start. There are some perf tradeoffs between (3) and (4) depending on how expensive WR precise hit testing is, and how often we need to call it relative to the number of transactions</li><ul class="indent"><li>1. Dumb c++ HT, main thread fallback &lt;-- this is the one that&#x27;s closest to what we have now, and probably what we will go with initially</li><li>2. Smart C++ hit test (needs new c++ code for precise hit testing, operating on the WR display items). &lt;-- this one seems like something we should avoid</li><li>3. WR hit testing (needs new code for precise hit testing) &lt;-- seems like where we want to end up finally</li><li>4. Dumb C++ hit test, WR fallback (needs new code for precise hit testing) &lt;-- this would be good second step to migrate towards a fully WR hit test (option 3)</li></ul></ul><li>on a WR transaction the hit testing structure will be built and passed to the C++ code along with the scroll metadata information</li><ul class="bullet"><li>with the &quot;new WR plan&quot; (i.e. using a layers backend) this is simplified because we can reuse the existing code that puts event regions on layers, and just send those event regions to the APZ in the form of WR items</li></ul><li>we will need to add new WR display items to represent areas with touch listeners or touch-action but no visible content (at least; there might be other scenarios)</li><li>we should add support for &quot;empty transactions&quot; in WR, where just the scroll position changes (within the existing displayport) and we just send that over without rebuilding the display list (so that we get paint-skipping in WR)</li><li>whiteboard pics: <a href="http&#x3a;&#x2F;&#x2F;people&#x2e;mozilla&#x2e;org&#x2F;&#x7e;kgupta&#x2F;apz&#x2d;webrender&#x2F;">http:&#x2F;&#x2F;people.mozilla.org&#x2F;~kgupta&#x2F;apz-webrender&#x2F;</a></li></ul><br><br>Things to be discussed and put in the right place:<br><ul class="bullet"><li>Gecko IPC vs. Rust IPC (events vs. fail when try, implications for security model, for GPU process restart, etc.)</li></ul><br>How to do SVG:<br><ul class="bullet"><li>need a path item so that simple geometry with color fills is just that</li><li>also make path items support stroke?</li><li>SVG supports arbitrary fill styles:</li><ul class="bullet"><li>solid color</li><li>linear gradient</li><li>radial gradient</li><li>pattern, i.e. arbitrary SVG &#x2F; HTML content that&#x27;s drawn with repeats</li></ul><li>How to do pattern fills? Draw the pattern contents to an image using legacy main thread painting?</li></ul><br><br>Android catch up(Jamie + Sotaro)<br><ul class="bullet"><li>Build on android&nbsp;</li><ul class="bullet"><li>Sotaro is going to check local build, then find out the amount of work.</li></ul><li>Add pause&#x2F;resume support for Composition with WebRender</li><ul class="bullet"><li>Affected&nbsp; by threading model</li></ul><li>infrastructure tests running</li><ul class="bullet"><li>ES3 vs ES2(exist in another category)</li></ul><li>Support android SurfaceTexture, SharedSurfaceEGL&nbsp; rendering - 1 week sotaro</li></ul><br>OMTA(pchang + Sotaro)<br><ul class="bullet"><li>Add support to Webrender(opacity and scaling)</li><ul class="bullet"><li>It is in webrender features needed from other discussions</li></ul><li>Relate Animation Item and stacking context and check OMTA with scrolling</li><li>layout works</li><ul class="bullet"><li>convert nsDisplayTransform and nsDisplayOpacity</li><li>dispatch animation&#x2F;animationdata to compositor for sampling</li></ul><li>Sampling animation during composition</li><li>Testing</li><ul class="bullet"><li>The followings related to testing of OMTA</li><ul class="bullet"><li>nsDOMWindowUtils::GetOMTAStyle()</li><li>SetTestSampleTime()</li><li>LeaveTestMode()</li></ul></ul></ul><br>webrender features needed from other discussions - glenn &#x2F; kvark &#x2F; lsalzman<br><ul class="bullet"><li>radial gradients - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;639">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;639</a></li><li>operator source - Originally needed by CLEAR_BACKGROUND display list, jeff thinks this isn&#x27;t quite needed, ask markus - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;643">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;643</a></li><li>complex images &#x2F; partial images + tiling - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;620">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;620</a></li><li>opacity and scaling change for OMTA and APZ - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;640">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;640</a></li><li>border-style: groove and ridge - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;641">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;641</a></li><li>MacIOSurface gl texture coordinate handling in shader - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;642">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;642</a></li><li>path rendering (sofrware first) - <a href="https&#x3a;&#x2F;&#x2F;github&#x2e;com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;402">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;webrender&#x2F;issues&#x2F;402</a></li></ul><br>Threading Model - nical &#x2F; kvark<br><ul class="bullet"><li>separate thread for the WR Renderer</li><li>split TextureHost between the IPDL and the renderer threads</li><li>hooking up APZ, Video, etc through it</li></ul><br>
</body>
</html>
