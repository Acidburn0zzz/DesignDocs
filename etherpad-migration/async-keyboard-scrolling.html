<!doctype html>
<html lang="en">
<head>
<title>async-keyboard-scrolling</title>
<meta name="generator" content="Etherpad">
<meta name="author" content="Etherpad">
<meta name="changedby" content="Etherpad">
<meta charset="utf-8">
<style>
* {
  font-family: arial, sans-serif;
  font-size: 13px;
  line-height: 17px;
}
ul.indent {
  list-style-type: none;
}
ol {
  list-style-type: none;
  padding-left: 0;
}
body > ol {
  counter-reset: first second third fourth fifth sixth seventh eigth ninth tenth eleventh twelth thirteenth fourteenth fifteenth sixteenth;
}
ol > li:before {
  content: counter(first) ". ";
  counter-increment: first;
}
ol > ol > li:before {
  content: counter(first) "." counter(second) ". ";
  counter-increment: second;
}
ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) ". ";
  counter-increment: third;
}
ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) ". ";
  counter-increment: fourth;
}
ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) ". ";
  counter-increment: fifth;
}
ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) ". ";
  counter-increment: sixth;
}
ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) ". ";
  counter-increment: seventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) ". ";
  counter-increment: eigth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) ". ";
  counter-increment: ninth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) ". ";
  counter-increment: tenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) ". ";
  counter-increment: eleventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) ". ";
  counter-increment: twelth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) ". ";
  counter-increment: thirteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) ". ";
  counter-increment: fourteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) ". ";
  counter-increment: fifteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eigth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) "." counter(sixthteenth) ". ";
  counter-increment: sixthteenth;
}
ol {
  text-indent: 0px;
}
ol > ol {
  text-indent: 10px;
}
ol > ol > ol {
  text-indent: 20px;
}
ol > ol > ol > ol {
  text-indent: 30px;
}
ol > ol > ol > ol > ol {
  text-indent: 40px;
}
ol > ol > ol > ol > ol > ol {
  text-indent: 50px;
}
ol > ol > ol > ol > ol > ol > ol {
  text-indent: 60px;
}
ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 70px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 80px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 90px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 100px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 110px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 120px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 130px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 140px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 150px;
}

</style>
</head>
<body>
<strong>Thoughts on APZ Keyboard Scrolling</strong><br><br>To perform async keyboard scrolling, APZ would need to know two things:<br><br>&nbsp; (1) How to map keyboard events to scroll actions (e.g. &quot;down arrow&quot; to &quot;scroll down by a line&quot;)<br><br><ul><ul class="bullet"><li>The main thread could build a table containing this mapping, and send it over to APZ.</li><ul class="bullet"><li>Things to figure out:</li><ul class="bullet"><li>Does the mapping depend on the type of element in focus?</li><ul class="bullet"><li>Ehsan believes it doesn&#x27;t.</li><ul class="bullet"><li>I don&#x27;t understand this. If one has &lt;textarea&gt;, arrow down usually just moves caret, but may scroll too if caret is at the last visible line.</li><ul class="bullet"><li>Yeah, scrolling in &lt;textarea&gt;s is probably something APZ won&#x27;t be able to do, because it would need to know how to move the caret as well, which would be quite difficult (it would need to know about character positions and such).</li><li>Also can&#x27;t scroll contenteditable elements or design mode</li></ul></ul></ul><li>Can the mapping change during runtime?</li><ul class="bullet"><li>If so, need to have the main thread send an update if it does.</li></ul></ul></ul></ul></ul><br>&nbsp; (2) What to scroll (roughly, the nearest enclosing scrollframe of the currently focused element)<br><br><ul><ul class="bullet"><li>Unlike other event types, there is no &quot;position&quot; associated with keyboard events that we could hit-test based on. It&#x27;s based on focus.</li><li>A possible design:</li><ul class="bullet"><li>Identify what types of events can potentially cause a focus change</li><ul class="bullet"><li>As a first pass, this could be &quot;everything&quot;.</li><li>Later we can refine it, possibly making it depend on the state of the page. For example, a mouse-move event can potentially cause a focus change *if* the page has registered an event listener for it.</li></ul><li>Have APZ assign a sequence number to all such events</li><ul class="bullet"><li>Note: this assumes all such events pass through APZ. If that&#x27;s not the case, that might be a problem.</li></ul><li>APZ maintains 3 pieces of state:</li><ul class="bullet"><li>CurrentlyFocusedScrollId</li><ul class="bullet"><li>identifies the (nearest enclosing scrollframe of) the currently focused element</li></ul><li>SequenceNumberAtLastFocusChange</li><ul class="bullet"><li>the sequence number of the last event the main thread processed before last updating CurrentlyFocusedScrollId</li></ul><li>LastSequenceNumber</li><ul class="bullet"><li>the sequence number of the last event (of a type that may potentially cause a focus change) that APZ received</li></ul><li>I&#x27;d propose changing SequenceNumberAtLastFocusChange and LastSequenceNumber to LastContentProcessedEvent and LastAPZProcessedEvent.</li><ul class="bullet"><li>There&#x27;s a possible complication here: Events can get forwarded to different content processes, or even not forwarded to any content process at all. Storing just one sequence number to express the information &quot;All preceding events have been processed&quot; may just be insufficient.</li></ul></ul><li>Whenever the main thread processes a focus change, it sends an updated (CurrentlyFocusedScrollId, SequenceNumberAtLastFocusChange) pair to APZ</li><ul class="bullet"><li>It can also send a &quot;null&quot; value for CurrentlyFocusedScrollId, if the thing currently focused can&#x27;t be scrolled by APZ (like a &lt;textarea&gt;)</li></ul><li>When APZ receives a keyboard event, it knows that CurrentlyFocusedScrollId is &quot;up to date&quot; as long as <strong>LastSequenceNumber == SequenceNumberAtLastFocusChange</strong></li><ul class="bullet"><li>(Otherwise, an event that came before the keyboard event but hasn&#x27;t been processed by the main thread yet might be about to cause a focus change.)</li><li>If it&#x27;s up to date, it consults the table from part (1), and scrolls the identified scroll frame.</li><ul class="bullet"><li>We can scroll only if the page doesn&#x27;t have listeners for key events or doesn&#x27;t call preventDefault</li><ul class="bullet"><li>Yep, good point. We have an existing mechanism for telling APZ whether the page has listeners for certain events, that we could extend for keyboard events.</li></ul></ul><li>Otherwise, it falls back to having the main thread handle the keyboard event.</li></ul></ul></ul></ul><br>Action Items<br><ul class="bullet"><li>add telemetry for keyboard and mousemove listeners (uplift to beta if possible)</li><li>propagate key events to APZ</li><li>key -&gt; action map in APZ</li><ul class="bullet"><li>from info in WidgetKeyboardEvent to &quot;scroll by line&quot; &#x2F; &quot;scroll by page&quot; etc.</li><li>note: might have multiple keys for a scroll action</li><ul class="bullet"><li>e.g. spacebar does page down</li></ul></ul><li>listener detection and notification to APZ</li><li>focus changes propagation to APZ</li><li>testing &#x2F; bug fxing</li><li>mouse listener notification</li></ul>
</body>
</html>
